<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pokemon Card Tracker</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Lucide icons as inline SVG components
    const Plus = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>;
    const Trash2 = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>;
    const RefreshCw = ({ className }) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>;
    const Download = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>;
    const Upload = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>;
    const Save = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" /></svg>;
    const ChevronDown = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /></svg>;

    function PokemonCardTracker() {
      const [cards, setCards] = useState([]);
      const [loading, setLoading] = useState({});
      const [searchResults, setSearchResults] = useState({});
      const [showDropdown, setShowDropdown] = useState({});
      const [showSetDropdown, setShowSetDropdown] = useState({});
      const [showNumberDropdown, setShowNumberDropdown] = useState({});
      
      // Store card data for dropdowns
      const [cardData, setCardData] = useState({});
      
      const dropdownRefs = useRef({});

      useEffect(() => {
        const saved = localStorage.getItem('pokemonCards');
        if (saved) {
          try {
            const parsedCards = JSON.parse(saved);
            setCards(parsedCards.length > 0 ? parsedCards : getDefaultCard());
          } catch (e) {
            console.error('Failed to load saved data');
            setCards(getDefaultCard());
          }
        } else {
          setCards(getDefaultCard());
        }
      }, []);

      const getDefaultCard = () => [{
        id: Date.now(),
        pokemon: '',
        cardNumber: '',
        set: '',
        quantity: 1,
        rawPrice: 0,
        lowPrice: 0,
        highPrice: 0
      }];

      useEffect(() => {
        if (cards.length > 0) {
          localStorage.setItem('pokemonCards', JSON.stringify(cards));
        }
      }, [cards]);

      useEffect(() => {
        const handleClickOutside = (event) => {
          Object.keys(dropdownRefs.current).forEach(id => {
            if (dropdownRefs.current[id] && !dropdownRefs.current[id].contains(event.target)) {
              setShowDropdown(prev => ({ ...prev, [id]: false }));
              setShowSetDropdown(prev => ({ ...prev, [id]: false }));
              setShowNumberDropdown(prev => ({ ...prev, [id]: false }));
            }
          });
        };

        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
      }, []);

      const addCard = () => {
        const newCard = {
          id: Date.now(),
          pokemon: '',
          cardNumber: '',
          set: '',
          quantity: 1,
          rawPrice: 0,
          lowPrice: 0,
          highPrice: 0
        };
        setCards([...cards, newCard]);
      };

      const removeCard = (id) => {
        if (cards.length <= 1) {
          alert("You need at least one card in the collection!");
          return;
        }
        setCards(cards.filter(card => card.id !== id));
      };

      const updateCard = (id, field, value) => {
        setCards(cards.map(card => 
          card.id === id ? { ...card, [field]: value } : card
        ));
      };

      // Search for Pokemon names
      const searchPokemon = async (id, query) => {
        if (!query || query.trim().length < 2) {
          setSearchResults(prev => ({ ...prev, [id]: [] }));
          setShowDropdown(prev => ({ ...prev, [id]: false }));
          return;
        }

        try {
          const url = `https://api.pokemontcg.io/v2/cards?q=name:${encodeURIComponent(query)}*&pageSize=20&orderBy=name`;
          const response = await fetch(url);
          
          if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
          }
          
          const data = await response.json();

          if (data.data) {
            // Get unique Pokemon names
            const uniqueNames = [];
            const seenNames = new Set();
            
            data.data.forEach(card => {
              if (!seenNames.has(card.name)) {
                seenNames.add(card.name);
                uniqueNames.push({
                  name: card.name,
                  id: card.id
                });
              }
            });
            
            setSearchResults(prev => ({ ...prev, [id]: uniqueNames }));
            setShowDropdown(prev => ({ ...prev, [id]: true }));
          }
        } catch (error) {
          console.error('Search error:', error);
          setSearchResults(prev => ({ ...prev, [id]: [] }));
        }
      };

      // When a Pokemon is selected, fetch all its cards
      const selectPokemon = async (cardId, pokemonName) => {
        updateCard(cardId, 'pokemon', pokemonName);
        updateCard(cardId, 'cardNumber', '');
        updateCard(cardId, 'set', '');
        setShowDropdown(prev => ({ ...prev, [cardId]: false }));
        
        // Fetch all cards for this Pokemon
        await fetchCardsForPokemon(cardId, pokemonName);
      };

      // Fetch all cards for a specific Pokemon
      const fetchCardsForPokemon = async (cardId, pokemonName) => {
        try {
          const url = `https://api.pokemontcg.io/v2/cards?q=name:"${encodeURIComponent(pokemonName)}"&pageSize=250`;
          const response = await fetch(url);
          const data = await response.json();

          if (data.data && data.data.length > 0) {
            // Organize cards by set
            const sets = {};
            data.data.forEach(card => {
              const setName = card.set.name;
              if (!sets[setName]) {
                sets[setName] = {
                  setName: setName,
                  cards: []
                };
              }
              
              // Add card if not already in the set (avoid duplicates)
              const existingCard = sets[setName].cards.find(c => c.number === card.number);
              if (!existingCard) {
                sets[setName].cards.push({
                  number: card.number,
                  id: card.id,
                  name: card.name,
                  rarity: card.rarity,
                  images: card.images
                });
              }
            });

            // Sort cards by number
            Object.values(sets).forEach(set => {
              set.cards.sort((a, b) => {
                // Try to sort numerically first, then alphabetically
                const aNum = parseInt(a.number);
                const bNum = parseInt(b.number);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                  return aNum - bNum;
                }
                return a.number.localeCompare(b.number);
              });
            });

            // Store the organized data
            setCardData(prev => ({
              ...prev,
              [cardId]: {
                pokemonName: pokemonName,
                sets: sets
              }
            }));

            // Auto-select the first set if available
            const setNames = Object.keys(sets);
            if (setNames.length > 0) {
              selectSet(cardId, setNames[0]);
            }
          }
        } catch (error) {
          console.error('Error fetching cards for Pokemon:', error);
          alert('Error loading card data. Please try again.');
        }
      };

      // When a set is selected
      const selectSet = (cardId, setName) => {
        updateCard(cardId, 'set', setName);
        updateCard(cardId, 'cardNumber', '');
        setShowSetDropdown(prev => ({ ...prev, [cardId]: false }));
        
        // Auto-select the first card in the set if available
        const cardInfo = cardData[cardId];
        if (cardInfo && cardInfo.sets[setName] && cardInfo.sets[setName].cards.length > 0) {
          selectCardNumber(cardId, cardInfo.sets[setName].cards[0].number);
        }
      };

      // When a card number is selected
      const selectCardNumber = async (cardId, cardNumber) => {
        updateCard(cardId, 'cardNumber', cardNumber);
        setShowNumberDropdown(prev => ({ ...prev, [cardId]: false }));
        
        // Fetch prices for this specific card
        const card = cards.find(c => c.id === cardId);
        if (card.pokemon && card.set) {
          await fetchPrices(cardId, card.pokemon, cardNumber, card.set);
        }
      };

      const fetchPrices = async (id, pokemon, cardNumber, setName) => {
        setLoading(prev => ({ ...prev, [id]: true }));

        try {
          const query = `name:"${pokemon}" set.name:"${setName}"${cardNumber ? ` number:${cardNumber}` : ''}`;
          const url = `https://api.pokemontcg.io/v2/cards?q=${encodeURIComponent(query)}`;
          
          const response = await fetch(url);
          const data = await response.json();

          if (data.data && data.data.length > 0) {
            const cardData = data.data[0];
            let rawPrice = 0, lowPrice = 0, highPrice = 0;

            if (cardData.tcgplayer?.prices) {
              const prices = cardData.tcgplayer.prices;
              const priceTypes = ['holofoil', 'reverseHolofoil', 'normal', 'unlimited', '1stEdition'];
              
              for (const type of priceTypes) {
                if (prices[type]) {
                  rawPrice = prices[type].market || prices[type].mid || prices[type].avg || 0;
                  lowPrice = prices[type].low || 0;
                  highPrice = prices[type].high || 0;
                  if (rawPrice > 0) break;
                }
              }
            }

            updateCard(id, 'rawPrice', parseFloat(rawPrice.toFixed(2)));
            updateCard(id, 'lowPrice', parseFloat(lowPrice.toFixed(2)));
            updateCard(id, 'highPrice', parseFloat(highPrice.toFixed(2)));
          } else {
            alert('No price data found for this card');
          }
        } catch (error) {
          console.error('Error fetching prices:', error);
          alert('Error fetching prices. Please try again.');
        } finally {
          setLoading(prev => ({ ...prev, [id]: false }));
        }
      };

      const getTotalValue = (priceType) => {
        return cards.reduce((sum, card) => {
          const price = parseFloat(card[priceType]) || 0;
          const qty = parseInt(card.quantity) || 0;
          return sum + (price * qty);
        }, 0).toFixed(2);
      };

      const saveToFile = () => {
        try {
          const dataStr = JSON.stringify(cards, null, 2);
          const blob = new Blob([dataStr], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `pokemon-collection-${new Date().toISOString().split('T')[0]}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (error) {
          alert('Error saving file: ' + error.message);
        }
      };

      const loadFromFile = (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const loaded = JSON.parse(e.target.result);
            if (Array.isArray(loaded) && loaded.length > 0) {
              setCards(loaded);
              alert('Collection loaded successfully!');
            } else {
              alert('Invalid file format. The file should contain an array of cards.');
            }
          } catch (error) {
            alert('Error loading file. Please make sure it is a valid JSON file.');
          }
        };
        reader.onerror = () => alert('Error reading file');
        reader.readAsText(file);
        
        event.target.value = '';
      };

      const exportToCSV = () => {
        try {
          const headers = ['Pokemon', 'Card Number', 'Set', 'Quantity', 'Market Price', 'Low Price', 'High Price', 'Total Value'];
          const rows = cards.map(card => [
            card.pokemon || '',
            card.cardNumber || '',
            card.set || '',
            card.quantity || 0,
            parseFloat(card.rawPrice) || 0,
            parseFloat(card.lowPrice) || 0,
            parseFloat(card.highPrice) || 0,
            ((parseFloat(card.rawPrice) || 0) * (parseInt(card.quantity) || 0)).toFixed(2)
          ]);

          const csvContent = [
            headers.join(','),
            ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
          ].join('\n');

          const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `pokemon-collection-${new Date().toISOString().split('T')[0]}.csv`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (error) {
          alert('Error exporting to CSV: ' + error.message);
        }
      };

      // Get available sets for a card
      const getAvailableSets = (cardId) => {
        const data = cardData[cardId];
        return data ? Object.keys(data.sets || {}).sort() : [];
      };

      // Get available card numbers for a specific set
      const getAvailableCardNumbers = (cardId, setName) => {
        const data = cardData[cardId];
        if (!data || !data.sets[setName]) return [];
        return data.sets[setName].cards.map(card => card.number);
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 p-4 md:p-6">
          <div className="max-w-7xl mx-auto">
            <div className="bg-white rounded-lg shadow-lg p-4 md:p-6 mb-6">
              <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 gap-4">
                <h1 className="text-2xl md:text-3xl font-bold text-gray-800">Pokemon Card Collection Tracker</h1>
                <div className="flex flex-wrap gap-2">
                  <label className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition cursor-pointer">
                    <Upload />
                    Load File
                    <input type="file" accept=".json" onChange={loadFromFile} className="hidden" />
                  </label>
                  <button onClick={saveToFile} className="flex items-center gap-2 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition">
                    <Save />
                    Save File
                  </button>
                  <button onClick={exportToCSV} className="flex items-center gap-2 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition">
                    <Download />
                    Export CSV
                  </button>
                </div>
              </div>

              <div className="mb-4 p-4 bg-blue-50 rounded-lg">
                <p className="text-sm text-gray-700">
                  <strong>How to use:</strong> Type Pokemon name → Select from dropdown → Set dropdown appears → Select Set → Card # dropdown appears → Select Card # → Prices auto-update.
                </p>
              </div>

              <div className="overflow-x-auto">
                <table className="w-full min-w-full">
                  <thead>
                    <tr className="border-b-2 border-gray-200">
                      <th className="text-left p-3 font-semibold text-gray-700">Pokemon Card</th>
                      <th className="text-left p-3 font-semibold text-gray-700">Card #</th>
                      <th className="text-left p-3 font-semibold text-gray-700">Set</th>
                      <th className="text-left p-3 font-semibold text-gray-700">Qty</th>
                      <th className="text-left p-3 font-semibold text-gray-700">Market</th>
                      <th className="text-left p-3 font-semibold text-gray-700">Low</th>
                      <th className="text-left p-3 font-semibold text-gray-700">High</th>
                      <th className="text-left p-3 font-semibold text-gray-700">Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {cards.map((card) => (
                      <tr key={card.id} className="border-b border-gray-100 hover:bg-gray-50">
                        <td className="p-3">
                          <div className="relative" ref={el => dropdownRefs.current[card.id] = el}>
                            <input
                              type="text"
                              value={card.pokemon}
                              onChange={(e) => {
                                updateCard(card.id, 'pokemon', e.target.value);
                                searchPokemon(card.id, e.target.value);
                              }}
                              onFocus={() => {
                                if (searchResults[card.id]?.length > 0) {
                                  setShowDropdown(prev => ({ ...prev, [card.id]: true }));
                                }
                              }}
                              placeholder="Type Pokemon name..."
                              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            />
                            {showDropdown[card.id] && searchResults[card.id]?.length > 0 && (
                              <div className="absolute z-50 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto">
                                {searchResults[card.id].map((result, idx) => (
                                  <div
                                    key={`${result.id || idx}-${card.id}`}
                                    onClick={() => selectPokemon(card.id, result.name)}
                                    className="p-3 hover:bg-blue-50 cursor-pointer border-b border-gray-100 last:border-b-0"
                                  >
                                    <div className="font-semibold text-gray-800">{result.name}</div>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        </td>
                        
                        {/* Card Number Field with Dropdown */}
                        <td className="p-3">
                          <div className="relative">
                            <div className="flex">
                              <input
                                type="text"
                                value={card.cardNumber}
                                readOnly
                                onClick={() => {
                                  if (card.pokemon && card.set) {
                                    setShowNumberDropdown(prev => ({ ...prev, [card.id]: true }));
                                  }
                                }}
                                className="w-24 px-3 py-2 border border-gray-300 rounded-l-lg cursor-pointer hover:bg-gray-50 bg-white"
                                placeholder="Select #"
                              />
                              <button
                                onClick={() => {
                                  if (card.pokemon && card.set) {
                                    setShowNumberDropdown(prev => ({ ...prev, [card.id]: true }));
                                  }
                                }}
                                className="px-2 py-2 border border-l-0 border-gray-300 rounded-r-lg hover:bg-gray-50"
                                disabled={!card.pokemon || !card.set}
                              >
                                <ChevronDown />
                              </button>
                            </div>
                            {showNumberDropdown[card.id] && card.pokemon && card.set && (
                              <div className="absolute z-50 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto">
                                {getAvailableCardNumbers(card.id, card.set).map((cardNumber, idx) => (
                                  <div
                                    key={`${cardNumber}-${idx}-${card.id}`}
                                    onClick={() => selectCardNumber(card.id, cardNumber)}
                                    className="p-3 hover:bg-blue-50 cursor-pointer border-b border-gray-100 last:border-b-0"
                                  >
                                    <div className="font-medium text-gray-800">#{cardNumber}</div>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        </td>
                        
                        {/* Set Field with Dropdown */}
                        <td className="p-3">
                          <div className="relative">
                            <div className="flex">
                              <input
                                type="text"
                                value={card.set}
                                readOnly
                                onClick={() => {
                                  if (card.pokemon) {
                                    setShowSetDropdown(prev => ({ ...prev, [card.id]: true }));
                                  }
                                }}
                                className="w-full px-3 py-2 border border-gray-300 rounded-l-lg cursor-pointer hover:bg-gray-50 bg-white"
                                placeholder="Select Set"
                              />
                              <button
                                onClick={() => {
                                  if (card.pokemon) {
                                    setShowSetDropdown(prev => ({ ...prev, [card.id]: true }));
                                  }
                                }}
                                className="px-2 py-2 border border-l-0 border-gray-300 rounded-r-lg hover:bg-gray-50"
                                disabled={!card.pokemon}
                              >
                                <ChevronDown />
                              </button>
                            </div>
                            {showSetDropdown[card.id] && card.pokemon && (
                              <div className="absolute z-50 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto">
                                {getAvailableSets(card.id).map((setName, idx) => (
                                  <div
                                    key={`${setName}-${idx}-${card.id}`}
                                    onClick={() => selectSet(card.id, setName)}
                                    className="p-3 hover:bg-blue-50 cursor-pointer border-b border-gray-100 last:border-b-0"
                                  >
                                    <div className="font-medium text-gray-800">{setName}</div>
                                    <div className="text-xs text-gray-500">
                                      {cardData[card.id]?.sets[setName]?.cards.length || 0} cards
                                    </div>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        </td>
                        
                        <td className="p-3">
                          <input 
                            type="number" 
                            value={card.quantity} 
                            onChange={(e) => updateCard(card.id, 'quantity', Math.max(0, parseInt(e.target.value) || 0))} 
                            min="0" 
                            className="w-20 px-3 py-2 border border-gray-300 rounded-lg" 
                          />
                        </td>
                        <td className="p-3">
                          <span className="text-green-600 font-semibold">${parseFloat(card.rawPrice || 0).toFixed(2)}</span>
                        </td>
                        <td className="p-3">
                          <span className="text-blue-600 font-semibold">${parseFloat(card.lowPrice || 0).toFixed(2)}</span>
                        </td>
                        <td className="p-3">
                          <span className="text-purple-600 font-semibold">${parseFloat(card.highPrice || 0).toFixed(2)}</span>
                        </td>
                        <td className="p-3">
                          <div className="flex gap-2">
                            <button 
                              onClick={() => fetchPrices(card.id, card.pokemon, card.cardNumber, card.set)} 
                              disabled={loading[card.id] || !card.pokemon || !card.set || !card.cardNumber}
                              className="p-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed" 
                              title="Refresh Prices"
                            >
                              <RefreshCw className={loading[card.id] ? "w-4 h-4 animate-spin" : "w-4 h-4"} />
                            </button>
                            <button 
                              onClick={() => removeCard(card.id)} 
                              className="p-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition" 
                              title="Remove Card"
                            >
                              <Trash2 />
                            </button>
                          </div>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>

              <button 
                onClick={addCard} 
                className="mt-4 flex items-center gap-2 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition"
              >
                <Plus />
                Add Card
              </button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="bg-white rounded-lg shadow-lg p-6">
                <h3 className="text-lg font-semibold text-gray-700 mb-2">Total Collection Value</h3>
                <p className="text-3xl font-bold text-green-600">${getTotalValue('rawPrice')}</p>
                <p className="text-sm text-gray-500 mt-1">Based on market prices</p>
              </div>
              <div className="bg-white rounded-lg shadow-lg p-6">
                <h3 className="text-lg font-semibold text-gray-700 mb-2">Low Estimate</h3>
                <p className="text-3xl font-bold text-blue-600">${getTotalValue('lowPrice')}</p>
                <p className="text-sm text-gray-500 mt-1">Conservative valuation</p>
              </div>
              <div className="bg-white rounded-lg shadow-lg p-6">
                <h3 className="text-lg font-semibold text-gray-700 mb-2">High Estimate</h3>
                <p className="text-3xl font-bold text-purple-600">${getTotalValue('highPrice')}</p>
                <p className="text-sm text-gray-500 mt-1">Optimistic valuation</p>
              </div>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<PokemonCardTracker />, document.getElementById('root'));
  </script>
</body>
</html>
